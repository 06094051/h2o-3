#'
#' KMeans Model
#'

h2o.kmeans <- function(data, cols, # AUTOGENERATED PARAMETERS:
                       centers, key, iter.max, normalize, init, seed #,dropNACol
) {# Set Input Parameters for Kmeans
  parms <- list()

  if(!missing(cols)) data <- data[,cols]
  # Verify Training Frame
  if(delete <- (data %i% "ASTNode")) invisible(nrow(data))
  #args <- .verify_datacols(data, cols)
  parms <- .addStringParm(parms, k = "training_frame", v = data@key)

  # AUTOGENERATED DEFAULT VALUES FOR PARAMETERS
  res <- .h2o.__remoteSend(data@h2o, paste0(.h2o.__MODEL_BUILDERS('kmeans') ))
  res <- res$model_builders$kmeans$parameters
  var_name <- sapply(res, function(param) param$name)
  var_value <- sapply(res, .convertFieldType )
  default_params <- mapply(assign, var_name, var_value)

  # Fill in missing parameters
  if(missing(centers)) centers <- default_params$"K"
  if(missing(iter.max)) iter.max <- default_params$"max_iters"
  if(missing(normalize)) normalize <- default_params$"normalize"
  if(missing(init)) init <- default_params$"init"
  if(missing(seed)) seed <- default_params$"seed"

  # Run check on R's side
  if(!missing(key)) {
    if(!is.character(key)) stop("key must be of class character")
    if(nchar(key) > 0 && regexpr("^[a-zA-Z_][a-zA-Z0-9_.]*$", key)[1] == -1)
      stop("key must match the regular expression '^[a-zA-Z_][a-zA-Z0-9_.]*$'")
    parms <- .addStringParm(parms, k = "destination_key", v = key)
  }
  if(!is.numeric(centers) && !is.integer(centers)) stop('centers must be a positive integer')
  if( any(centers < 1) ) stop("centers must be an integer greater than 0")
  if(!is.numeric(iter.max)) stop('iter.max must be numeric')
  if( any(iter.max < 1)) stop('iter.max must be >= 1')
  if(!is.logical(normalize)) stop("normalize must be logical")
  myInit <- switch(init, none = "None", plusplus = "PlusPlus", furthest = "Furthest")
  if(length(init) > 1 || !init %in% c("None", "PlusPlus", "Furthest"))
    stop("init must be one of 'None', 'PlusPlus', 'Furthest'")
  if(!is.numeric(seed)) stop("seed must be numeric")
#  if(!is.logical(dropNACols)) stop("dropNACols must be logical")

  # Add parameters to be posted to Kmeans Model Building Page
  parms <- .addIntParm(parms, k = "K", v = centers)
  parms <- .addIntParm(parms, k = "max_iters", v = iter.max)
  parms <- .addBooleanParm(parms, k = "normalize", v = normalize)
  parms <- .addStringParm(parms, k = "init", v = init)
  parms <- .addDoubleParm(parms, k = "seed", v = seed)

  # Post Kmeans Parameters to build Model
  model_params <- .h2o.__remoteSend(data@h2o, '2/KMeans.json', .params = parms)
  res <- .h2o.__remoteSend(data@h2o, method = "POST", .h2o.__MODEL_BUILDERS('kmeans'),
                           .params = parms)
  job_key <- res$key$name
  dest_key <- res$jobs[[1]]$dest$name
  .h2o.__waitOnJob(data@h2o, job_key)
  # Grab model output and flatten one level
  res_model <- .h2o.__remoteSend(data@h2o, method = "POST", .h2o.__MODELS %p0% dest_key)
  res_model <- unlist(res_model, recursive = F)
  res_model <- res_model$models
  model_output <- res_model$output
  model_parameters <- res_model$parameters
#  return(res_model)

  # Delete temporary H2OFrame created from ASTNode
  if(delete) h2o.rm("data")

  # Create new KMeans Model Object
  new("H2OKMeansModel", h2o = data@h2o, key = dest_key,
      model = model_output, valid = new("H2OParsedData", h2o=data@h2o, key="NA"))
  }