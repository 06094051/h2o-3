#'
#' Singular Value Decomposition
#'
#' Singular value decomposition of a H2O dataset using the power method.
#'
#'
#' @param training_frame An \linkS4class{H2OFrame} object containing the
#'        variables in the model.
#' @param x (Optional) A vector containing the data columns on which SVD operates.
#' @param nv The number of right singular vectors to be computed. This must be
#'        between 1 and min(ncol(training_frame), nrow(training_frame)) inclusive.
#' @param max_iterations The maximum number of iterations to run each power
#'        iteration loop. Must be between 1 and 1e6 inclusive.
#' @param center A logical value indicating whether to subtract the mean from 
#'        each column so it is zero-centered.
#' @param scale. A logical value indicating whether to divide each column by
#'        the standard deviation so it has unit variance.
#' @param seed (Optional) Random seed used to initialize the right singular vectors
#'        at the beginning of each power method iteration.
#' @return Returns an object of class \linkS4class{H2ODimReductionModel}.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' ausPath <- system.file("extdata", "australia.csv", package="h2o")
#' australia.hex <- h2o.uploadFile(localH2O, path = ausPath)
#' h2o.svd(training_frame = australia.hex, nv = 8)
#' @export
h2o.svd <- function(training_frame, x, nv, center = FALSE, scale. = FALSE,
                    ## AUTOGENERATED PARAMETERS ##     # these defaults are not read by h2o
                    max_iterations = 1000,             # h2o generates its own default parameters
                    seed)
{
  # Required args: training_frame
  if( missing(training_frame) ) stop("argument \"training_frame\" is missing, with no default")
  
  # Training_frame may be a key or an H2OFrame object
  if (!inherits(training_frame, "H2OFrame"))
    tryCatch(training_frame <- h2o.getFrame(training_frame),
             error = function(err) {
               stop("argument \"training_frame\" must be a valid H2OFrame or key")
             })
  
  ## -- Force evaluate temporary ASTs -- ##
  delete <- !.is.eval(training_frame)
  if( delete ) {
    temp_key <- training_frame@key
    .h2o.eval.frame(conn = training_frame@conn, ast = training_frame@mutable$ast, key = temp_key)
  }
  
  # Gather user input
  parms <- list()
  parms$training_frame <- training_frame
  if(!missing(x))
    parms$ignored_columns <- .verify_datacols(training_frame, x)$cols_ignore
  if(!missing(nv))
    parms$nv <- as.numeric(nv)    # TODO: Want default to min(n,p) where n = nrow, p = ncol of adapted training_frame
  if(!missing(max_iterations))
    parms$max_iterations <- max_iterations
  if(!missing(seed))
    parms$seed <- seed
  
  if(center && scale.)
    parms[["transform"]] <- "STANDARDIZE"
  else if(center && !scale.)
    parms[["transform"]] <- "DEMEAN"
  else if(!center && scale.)
    parms[["transform"]] <- "DESCALE"
  else
    parms[["transform"]] <- "NONE"
  parms[["center"]] <- NULL
  parms[["scale."]] <- NULL
  
  # Error check and build model
  .h2o.createModel(training_frame@conn, 'svd', parms)
}