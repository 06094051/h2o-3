#' Build a Big Data Random Forest Model
#'
#' Builds a Random Forest Model on an \linkS4class{H2OFrame}
#'
#' @param x A vector containing the names or indices of the predictor variables
#'        to use in building the GBM model.
#' @param y The name or index of the response variable. If the data does not
#'        contain a header, this is the column index number starting at 1, and
#'        increasing from left to right. (The response must be either an integer
#'        or a categorical variable).
#' @param training_frame An \code{\linkS4class{H2OFrame}} object containing the
#'        variables in the model.
#' @param destination_key (Optional) The unique hex key assigned to the
#'        resulting model. If none is given, a key will automatically be
#'        generated.
#' @param mtries Columns to randomly select at each level, or -1 for
#'        sqrt(#cols).
#' @param sample_rate Sample rate, from 0. to 1.0.
#' @param build_tree_one_node Run on one node only; no network overhead but
#'        fewer cpus used.  Suitable for small datasets.
#' @param ntrees A nonnegative integer that determines the number of trees to
#'        grow.
#' @param max_depth Maximum depth to grow the tree.
#' @param min_rows Minimum number of rows to assign to teminal nodes.
#' @param nbins Number of bins to use in building histogram.
#' @param validation_frame
#' @param balance_classes logical, indicates whether or not to balance training
#'        data class counts via over/under-sampling (for imbalanced data)
#' @param score_each_iteration
#' @param seed Seed for random numbers (affects sampling) - Note: only
#'        reproducible when running single threaded
#' @return Creates a \linkS4class{H2OModel} object of the right type.
##' export
#' @export
h2o.randomForest <- function( x, y, training_frame, ...,
                             #AUTOGENERATED params
                             destination_key,
                             validation_frame,
                             mtries = -1,
                             sample_rate = 0.6666667,
                             build_tree_one_node = FALSE,
                             ntrees = 50,
                             max_depth = 20,
                             min_rows = 1,
                             nbins = 20,
                             balance_classes = FALSE,
                             score_each_iteration = FALSE,
                             seed) {

  dots <- list(...)

  for(type in names(dots))
    if (is.environment(dots[[type]])) {
    dots$envir <- type
    type <- NULL
    } else {
      stop(paste0("\n  unused argument (", type, " = ", deparse(dots[[type]]), ")"))
    }
  if (is.null(dots$envir))
    dots$envir <- parent.frame()

  # Required args: x, y, training_frame
  if( missing(x) ) stop("`x` is missing, with no default")
  if( missing(y) ) stop("`y` is missing, with no default")
  if( missing(training_frame) ) stop("`training_frame` is missing, with no default")

  # Training_frame and validation_frame may be a key or an H2OFrame object
  if (!inherits(training_frame, "H2OFrame"))
    tryCatch(training_frame <- h2o.getFrame(training_frame),
             error = function(err) {
               stop("argument \"training_frame\" must be a valid H2OFrame or key")
             })

 if (!missing(validation_frame)) {
    if (!inherits(validation_frame, "H2OFrame"))
        tryCatch(validation_frame <- h2o.getFrame(validation_frame),
                 error = function(err) {
                   stop("argument \"validation_frame\" must be a valid H2OFrame or key")
                 })
  }

  #required map for params with different names, assuming it will change in the RESTAPI end
  .drf.map <- c("x" = "ignored_columns",
                "y" = "response_column")

  parms <- as.list(match.call(expand.dots = FALSE)[-1L])
  parms$... <- NULL

  args <- .verify_dataxy(training_frame, x, y)
  parms$x <- args$x_ignore
  parms$y <- args$y

  names(parms) <- lapply(names(parms), function(i) { if( i %in% names(.drf.map) ) i <- .drf.map[[i]]; i })

 .h2o.createModel(training_frame@conn, 'drf', parms, dots$envir)
}