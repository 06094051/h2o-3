#' Gradient Boosted Machines
#'
#' Builds gradient boosted classification trees, and gradient boosted regression trees on a parsed data set.
#'
#' @param x A vector containing the names or indices of the predictor variables to use in building the GBM model.
#' @param y The name or index of the response variable. If the data does not contain a header, this is the column index number starting at 0, and increasing from left to right. (The response must be either an integer or a categorical variable).
#' @param data An \code{\linkS4class{H2OParsedData}} object containing the variables in the model.
#' @param key (Optional) The unique hex key assigned to the resulting model. If none is given, a key will automatically be generated.
#' @param loss A \code{character} string. The loss function to be implemented. Must be "AUTO" or "Bernoulli"
#' @param ntrees Number of trees to grow. Must be a nonnegative integer.
#' @param max_depth Maximum depth to grow the tree.
#' @param min_rows Minimum number of rows to assign to teminal nodes.
#' @param learn_rate An \code{interger} from \code{0.0} to \code{1.0}
#' @param nbins Number of bins to use in building histogram.
#' @param group_split  #TODO NEED TO FINISH
#' @param variable_importance #TODO: NEED TO FINISH
#' @param validation_frame An \code{\link{H2OParsedData}} object indicating the validation dataset used to contruct the confusion matrix. If left blank, this defaults to the training data when \code{nfolds = 0}
#' @param balance_classes (Optional) Balance training data class counts via over/under-sampling (for imbalanced data)
#' @param max_after_balance_size Maximum relative size of the training data after balancing class counts (can be less than 1.0)
#' @param seed Seed for random numbers (affects sampling) - Note: only reproducible when running single threaded
#' @param nfolds (Optional) Number of folds for cross-validation. If \code{nfolds >= 2}, then \code{validation} must remain empty.
#' @seealso \code\link{predict.H2OGBMModel} for prediction.
#' @examples
#' #TODO GBM wasn't working example needs to be redone, maybe
#' library(h2o)
#' localH2O = h2o.init()
#'
#' # Run regression GBM on australia.hex data
#' ausPath = system.file("extdata", "australia.csv", package="h2o")
#' australia.hex = h2o.importFile(localH2O, path = ausPath)
#' independent <- c("premax", "salmax","minairtemp", "maxairtemp", "maxsst", "maxsoilmoist", "Max_czcs")
#' dependent <- "runoffnew"
#' h2o.gbm(y = dependent, x = independent, data = australia.hex, ntrees = 3, max_depth = 3, min_rows = 2)

h2o.gbm <- function(x, y, data, key="",
                    #AUTOGENERATED param
                    loss,
                    ntrees,
                    max_depth,
                    min_rows,
                    learn_rate,
                    nbins,
                    group_split,
                    variable_importance,
                    validation_frame,
                    balance_classes,
                    max_after_balance_size,
                    seed,
                    # group_split
                    nfolds = 0)
{
  # Set Input Parameters for GBM
  parms = list()

  if(data %i% "ASTNode") delete = TRUE && invisible(nrow(data)) else delete = FALSE

  # Verify Training Frame
  args <- .verify_dataxy(data, x, y)

  parms <- .addStringParm(parms, k = "training_frame", v = data@key)
  parms$response_column = args$y
  parms$ignored_columns = args$x_ignore

  if(!is.character(key)) stop("key must be of class character")
  if(nchar(key) > 0 && regexpr("^[a-zA-Z_][a-zA-Z0-9_.]*$", key)[1] == -1)
    stop("key must match the regular expression '^[a-zA-Z_][a-zA-Z0-9_.]*$'")
  parms$destination_key = key

  if(!is.numeric(nfolds)) stop("nfolds must be numeric")
  if(nfolds == 1) stop("nfolds cannot be 1")
  if(!missing(validation_frame) && class(validation_frame) != "H2OParsedData") stop("validation must be an H2O parsed dataset")

  if(missing(validation_frame) && nfolds == 0) {
    validation_frame = new ("H2OParsedData", key = as.character(NA))
    parms$validation_frame = validation_frame@key
    #parms$n_folds = nfolds
  } else if(missing(validation_frame) && nfolds >= 2) {
    validation_frame = new("H2OParsedData", key = as.character(NA))
    #parms$n_folds = nfolds
  } else if(!missing(validation_frame) && nfolds == 0)
    parms$validation_frame = validation_frame@key
  else stop("Cannot set both validation and nfolds at the same time")

  # ----- AUTOGENERATED PARAMETERS BEGIN -----
  parms = .addStringParm(parms, k = "loss", v = loss)
  parms = .addIntParm(parms, k = "ntrees", v = ntrees )
  parms = .addIntParm(parms, k = "max_depth", v = max_depth )
  parms = .addIntParm(parms, k = "min_rows", v = min_rows )
  parms = .addFloatParm(parms, k = "learn_rate", v = learn_rate)
  parms = .addIntParm(parms, k = "nbins", v = nbins )
  parms = .addBooleanParm(parms, k = "variable_importance", v = variable_importance)
  parms = .addLongParm(parms, k="seed", v=seed)
  parms = .addLongParm(parms, k = "balance_classes", v = balance_classes )
  parms = .addLongParm(parms, k = "max_after_balance_size", v = max_after_balance_size )
  #parms = .addBooleanParm(parms, k = "group_split", v = group_split )

  model_params <- .h2o.__remoteSend(data@h2o, method = "POST", '2/GBM.json', .params = parms)
  res <- .h2o.__remoteSend(data@h2o, method = "POST", h2o.__MODEL_BUILDERS('gbm'), .params = parms)

  #parms$h2o <- data@h2o
  parms$h2o <- data@h2o

  job_key <- res$key$name
  dest_key <- res$jobs[[1]]$dest$name
  .h2o.__waitOnJob(data@h2o, job_key)
  res_model <- list()
  res_model$params <- model_params
  new("H2OGBMModel", h2o = data@h2o, key = dest_key, data = data, model = res_model, valid = new("H2OParsedData", h2o=data@h2o, key="NA"), xval = list())
}