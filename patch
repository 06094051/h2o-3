diff --git a/h2o-core/src/main/java/hex/quantile/Quantile.java b/h2o-core/src/main/java/hex/quantile/Quantile.java
index 6766589..3506119 100755
--- a/h2o-core/src/main/java/hex/quantile/Quantile.java
+++ b/h2o-core/src/main/java/hex/quantile/Quantile.java
@@ -67,7 +67,13 @@ public class Quantile extends ModelBuilder<QuantileModel,QuantileModel.QuantileP
 
     private class SumWeights extends MRTask<SumWeights> {
       double sum;
-      @Override public void map(Chunk c, Chunk w) { for (int i=0;i<c.len();++i) if (!c.isNA(i)) sum+=w.atd(i); }
+      @Override public void map(Chunk c, Chunk w) { for (int i=0;i<c.len();++i)
+        if (!c.isNA(i)) {
+          double wt = w.atd(i);
+//          if (wt > 0 && wt < 1) throw new H2OIllegalArgumentException("Quantiles only accepts weights that are either 0 or >= 1.");
+          sum += wt;
+        }
+      }
       @Override public void reduce(SumWeights mrt) { sum+=mrt.sum; }
     }
 
@@ -100,6 +106,7 @@ public class Quantile extends ModelBuilder<QuantileModel,QuantileModel.QuantileP
           // Compute top-level histogram
           Histo h1 = new Histo(vec.min(),vec.max(),0,sumRows,vec.isInt());
           h1 = _weights==null ? h1.doAll(vec) : h1.doAll(vec, _weights);
+          Log.info("Orig:\n"+h1);
 
           // For each probability, see if we have it exactly - or else run
           // passes until we do.
@@ -107,9 +114,11 @@ public class Quantile extends ModelBuilder<QuantileModel,QuantileModel.QuantileP
             double prob = _parms._probs[p];
             Histo h = h1;  // Start from the first global histogram
 
+            Log.info("\nProb: " + prob);
             model._output._iterations++; // At least one iter per-prob-per-column
             while( Double.isNaN(model._output._quantiles[n][p] = h.findQuantile(prob,_parms._combine_method)) ) {
               h = h.refinePass(prob).doAll(vec); // Full pass at higher resolution
+              Log.info("Refined:\n" + h);
               model._output._iterations++; // also count refinement iterations
             }
 
@@ -183,7 +192,7 @@ public class Quantile extends ModelBuilder<QuantileModel,QuantileModel.QuantileP
   // -------------------------------------------------------------------------
 
   private static class Histo extends MRTask<Histo> {
-    private static final int NBINS=1024; // Default bin count
+    private static final int NBINS=4; // Default bin count
     private final int _nbins;            // Actual  bin count
     private final double _lb;            // Lower bound of bin[0]
     private final double _step;          // Step-size per-bin
@@ -193,6 +202,7 @@ public class Quantile extends ModelBuilder<QuantileModel,QuantileModel.QuantileP
 
     // Big Data output result
     double _bins[/*nbins*/];     // Weighted count of rows in each bin
+    double _psum[/*nbins*/];     // Partial sums
     double _mins[/*nbins*/];     // Smallest element in bin
     double _maxs[/*nbins*/];     // Largest  element in bin
 
@@ -207,26 +217,38 @@ public class Quantile extends ModelBuilder<QuantileModel,QuantileModel.QuantileP
       _isInt = isInt;
     }
 
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder();
+      sb.append(  "psum0 : " + _start_row);
+      sb.append("\ncounts: " + Arrays.toString(_bins));
+      sb.append("\npsum  : " + Arrays.toString(_psum));
+      sb.append("\nmaxs  : " + Arrays.toString(_maxs));
+      sb.append("\nmins  : " + Arrays.toString(_mins));
+      sb.append("\n");
+      return sb.toString();
+    }
+
     @Override public void map( Chunk chk, Chunk weight) {
-      double bins[] = _bins = new double[_nbins];
-      double mins[] = _mins = new double[_nbins];
-      double maxs[] = _maxs = new double[_nbins];
+      _bins = new double[_nbins];
+      _mins = new double[_nbins];
+      _maxs = new double[_nbins];
       Arrays.fill(_mins, Double.MAX_VALUE);
-      Arrays.fill(_maxs,-Double.MAX_VALUE);
+      Arrays.fill(_maxs, -Double.MAX_VALUE);
       double d;
       for( int row=0; row<chk._len; row++ ) {
         double w = weight.atd(row);
         if (w == 0) continue;
         if (!Double.isNaN(d = chk.atd(row))) {  // na.rm=true
           double idx = (d - _lb) / _step;
-          if (!(0.0 <= idx && idx < bins.length)) continue;
+          if (!(0.0 <= idx && idx < _bins.length)) continue;
           int i = (int) idx;
-          if (bins[i] == 0) mins[i] = maxs[i] = d; // Capture unique value
+          if (_bins[i] == 0) _mins[i] = _maxs[i] = d; // Capture unique value
           else {
-            if (d < mins[i]) mins[i] = d;
-            if (d > maxs[i]) maxs[i] = d;
+            if (d < _mins[i]) _mins[i] = d;
+            if (d > _maxs[i]) _maxs[i] = d;
           }
-          bins[i]+=w;               // Bump row counts by row weight
+          _bins[i]+=w;               // Bump row counts by row weight
         }
       }
     }
@@ -238,45 +260,107 @@ public class Quantile extends ModelBuilder<QuantileModel,QuantileModel.QuantileP
         if( _mins[i] > h._mins[i] ) _mins[i] = h._mins[i];
         if( _maxs[i] < h._maxs[i] ) _maxs[i] = h._maxs[i];
       }
-      ArrayUtils.add(_bins,h._bins);
+      ArrayUtils.add(_bins, h._bins);
+    }
+
+    @Override
+    protected void postGlobal() {
+      _psum = new double[_nbins];
+      _psum[0] = _bins[0];
+      for( int i=1; i<_nbins; i++ ) { // Keep min/max
+        _psum[i] = _psum[i-1];
+        _psum[i] += _bins[i];
+      }
+      Log.info(Arrays.toString(_psum));
     }
 
     /** @return Quantile for probability prob, or NaN if another pass is needed. */
     double findQuantile( double prob, QuantileModel.CombineMethod method ) {
-      double p2 = prob*(_nrows-1); // Desired fractional row number for this probability
-      long r2 = (long)p2;
-      int loidx = findBin(r2);  // Find bin holding low value
+//      double p2 = prob*(_nrows-1); // Desired fractional row number for this probability
+//      long r2 = (long)p2;
+//      int loidx = findBin(r2);  // Find bin holding low value
+
+      double p2 = prob*_nrows; // Desired fractional row number for this probability
+      Log.info("Looking for point that has " + p2 + " cumulative weighted count");
+      int loidx = findBin(p2);  // Find bin holding low value
+      Log.info("Found bin index: " + loidx);
+
+      while (_bins[loidx]==0) loidx--;
+      assert(_bins[loidx] > 0);
+      // sanity check - prob must be in this bin
+//      assert(prob >= (_start_row + _psum[loidx])/_nrows);
+      //if (loidx < _nbins-1) assert(prob < (_start_row + _psum[loidx+1])/_nrows);
+
+      if (_psum[loidx] > prob && _mins[loidx] < _maxs[loidx]) {
+        return Double.NaN;
+      }
+
       double lo = (loidx == _nbins) ? binEdge(_nbins) : _maxs[loidx];
-      if( loidx<_nbins && r2==p2 && _mins[loidx]==lo ) return lo; // Exact row number, exact bin?  Then quantile is exact
+//      if( loidx<_nbins && p2==(long)p2 && _mins[loidx]==lo ) {
+//        Log.info("Found exact quantile: " + lo);
+//        return lo; // Exact row number, exact bin?  Then quantile is exact
+//      }
+
+//      long r3 = r2+1;
+//      double r3 = p2+1;
+//      int hiidx = findBin(r3);  // Find bin holding high value
+//      double hi = (hiidx == _nbins) ? binEdge(_nbins) : _mins[hiidx];
+//      if( loidx==hiidx ) {        // Somewhere in the same bin?
+//        if (lo==hi) Log.info("Constant bin -> Found quantile: " + lo);
+//        return (lo == hi) ? lo : Double.NaN; // Only if bin is constant, otherwise must refine the bin
+//      }
+
+
+      int hiidx = (loidx == _nbins-1) ? loidx : loidx+1;
+      while (_bins[hiidx]==0) hiidx++;
+      assert(_bins[hiidx] > 0);
+      if (_psum[loidx] == _psum[hiidx]) {
+        Log.info("Partial sum not increasing: Found quantile: " + lo);
+        return lo;
+      }
+      double hi = _mins[hiidx];
 
-      long r3 = r2+1;
-      int hiidx = findBin(r3);  // Find bin holding high value
-      double hi = (hiidx == _nbins) ? binEdge(_nbins) : _mins[hiidx];
-      if( loidx==hiidx )        // Somewhere in the same bin?
-        return (lo==hi) ? lo : Double.NaN; // Only if bin is constant, otherwise must refine the bin
       // Split across bins - the interpolate between the hi of the lo bin, and
       // the lo of the hi bin
-      return computeQuantile(lo,hi,r2,_nrows,prob,method);
+      Log.info("Interpolate between: " + lo + " and " + hi + " low index: " + loidx);
+//      double val = computeQuantile(lo,hi,r2,_nrows,prob,method);
+      double val = computeQuantile(lo,hi,loidx,hiidx,prob,method);
+      Log.info("interpolated value: " + val);
+      return val;
     }
 
     private double binEdge( int idx ) { return _lb+_step*idx; }
 
     // bin for row; can be _nbins if just off the end (normally expect 0 to nbins-1)
-    // row == position in (weighted) population
-    private int findBin( double row ) {
-      long sum = (long)_start_row;
-      for( int i=0; i<_nbins; i++ )
-        if( (long)row < (sum += _bins[i]) )
-          return i;
-      return _nbins;
+    // psum == position in (weighted) population
+    private int findBin( double psum ) {
+      int pos = Arrays.binarySearch(_psum, psum);
+      if (pos < 0) pos = -pos-1;
+//      if (pos >= 1 && _psum[pos] > psum && _psum[pos-1] <= psum) return pos-1;
+      //if (_psum[pos] <= psum && _psum[pos+1] > psum) return pos;
+//
+//      double sum = _start_row;
+//      int pos = 0;
+//      for(int i=0; i<_nbins; i++ ) {
+//        sum += _bins[i];
+//        if (sum < psum)  {
+//          pos++;
+//        } else {
+//          return pos;
+//        }
+//      }
+//      return _nbins;
+      return pos;
     }
 
     // Run another pass over the data, with refined endpoints, to home in on
     // the exact elements for this probability.
     Histo refinePass( double prob ) {
-      double prow = prob*(_nrows-1); // Desired fractional row number for this probability
-      long lorow = (long)prow;       // Lower integral row number
-      int loidx = findBin(lorow);    // Find bin holding low value
+//      double prow = prob*(_nrows-1); // Desired fractional row number for this probability
+//      long lorow = (long)prow;       // Lower integral row number
+//      int loidx = findBin(lorow);    // Find bin holding low value
+      double prow = prob*_nrows; // Desired fractional row number for this probability
+      int loidx = findBin(prow);    // Find bin holding low value
       // If loidx is the last bin, then high must be also the last bin - and we
       // have an exact quantile (equal to the high bin) and we didn't need
       // another refinement pass
@@ -284,46 +368,57 @@ public class Quantile extends ModelBuilder<QuantileModel,QuantileModel.QuantileP
       double lo = _mins[loidx]; // Lower end of range to explore
       // If probability does not hit an exact row, we need the elements on
       // either side - so the next row up from the low row
-      long hirow = lorow==prow ? lorow : lorow+1;
+//      long hirow = lorow==prow ? lorow : lorow+1;
+      double hirow = prow; //lorow==(long)prow ? lorow : lorow+1;
       int hiidx = findBin(hirow);    // Find bin holding high value
       // Upper end of range to explore - except at the very high end cap
       double hi = hiidx==_nbins ? binEdge(_nbins) : _maxs[hiidx];
 
-      long sum = (long)_start_row;
+//      long sum = (long)_start_row;
+      double sum = _start_row;
       for( int i=0; i<loidx; i++ )
         sum += _bins[i];
+      Log.info("Refining: " + lo + "..." + hi + " with partial sum: " + sum);
       return new Histo(lo,hi,sum,_nrows,_isInt);
     }
-  }
 
-  /** Compute the correct final quantile from these 4 values.  If the lo and hi
-   *  elements are equal, use them.  However if they differ, then there is no
-   *  single value which exactly matches the desired quantile.  There are
-   *  several well-accepted definitions in this case - including picking either
-   *  the lo or the hi, or averaging them, or doing a linear interpolation.
-   *  @param lo  the highest element less    than or equal to the desired quantile
-   *  @param hi  the lowest  element greater than or equal to the desired quantile
-   *  @param row row number (zero based) of the lo element; high element is +1
-   *  @return desired quantile. */
-  static double computeQuantile( double lo, double hi, double row, double nrows, double prob, QuantileModel.CombineMethod method ) {
-    if( lo==hi ) return lo;     // Equal; pick either
-    if( method == null ) method= QuantileModel.CombineMethod.INTERPOLATE;
-    switch( method ) {
-    case INTERPOLATE: return linearInterpolate(lo,hi,row,nrows,prob);
-    case AVERAGE:     return 0.5*(hi+lo);
-    case LOW:         return lo;
-    case HIGH:        return hi;
-    default:
-      Log.info("Unknown even sample size quantile combination type: " + method + ". Doing linear interpolation.");
-      return linearInterpolate(lo,hi,row,nrows,prob);
+    private double linearInterpolate(double lo, double hi, int loidx, int hiidx, double prob) {
+      // Unequal, linear interpolation
+//    double plo = (row+0)/(nrows-1); // Note that row numbers are inclusive on the end point, means we need a -1
+//    double phi = (row+1)/(nrows-1); // Passed in the row number for the low value, high is the next row, so +1
+      double sumlo = _start_row + _psum[loidx];
+      double sumhi = _start_row + _psum[hiidx];
+      double plo = sumlo/_nrows;
+      double phi = sumhi/_nrows;
+      return lo + (hi-lo)*(prob-plo)/(phi-plo);
+
+//      double plo = (row+0           )/(_nrows); // Note that row numbers are inclusive on the end point, means we need a -1
+//      double phi = loidx < _bins.length ? (row+_bins[loidx])/(_nrows) : plo; // Passed in the row number for the low value, high is the next row, so +1
+//      assert plo <= prob && prob <= phi;
+//      return lo + (hi-lo)*(prob-plo)/(phi-plo); // Classic linear interpolation
     }
-  }
 
-  private static double linearInterpolate(double lo, double hi, double row, double nrows, double prob) {
-    // Unequal, linear interpolation
-    double plo = (row+0)/(nrows-1); // Note that row numbers are inclusive on the end point, means we need a -1
-    double phi = (row+1)/(nrows-1); // Passed in the row number for the low value, high is the next row, so +1
-    assert plo <= prob && prob <= phi;
-    return lo + (hi-lo)*(prob-plo)/(phi-plo); // Classic linear interpolation
+    /** Compute the correct final quantile from these 4 values.  If the lo and hi
+     *  elements are equal, use them.  However if they differ, then there is no
+     *  single value which exactly matches the desired quantile.  There are
+     *  several well-accepted definitions in this case - including picking either
+     *  the lo or the hi, or averaging them, or doing a linear interpolation.
+     *  @param lo  the highest element less    than or equal to the desired quantile
+     *  @param hi  the lowest  element greater than or equal to the desired quantile
+     *  @return desired quantile. */
+    double computeQuantile( double lo, double hi, int loidx, int hiidx, double prob, QuantileModel.CombineMethod method ) {
+      if( lo==hi ) return lo;     // Equal; pick either
+      if( method == null ) method= QuantileModel.CombineMethod.INTERPOLATE;
+      switch( method ) {
+        case INTERPOLATE: return linearInterpolate(lo,hi,loidx,hiidx,prob);
+        case AVERAGE:     return 0.5*(hi+lo);
+        case LOW:         return lo;
+        case HIGH:        return hi;
+        default:
+          Log.info("Unknown even sample size quantile combination type: " + method + ". Doing linear interpolation.");
+          return linearInterpolate(lo,hi,loidx,hiidx,prob);
+      }
+    }
   }
+
 }
