//
// The top-level h2o-3 project does not have any java pieces itself, but
// apply from the standard java.gradle so that 'gradle idea' generates IDE
// files with the right settings.
//
// The top-level jar file that gets produced is empty and not usable
// for anything.  Use the jar file produced by the h2o-assembly subproject.
//
apply from: 'gradle/java.gradle'

// For multiproject setup we have to apply release plugin here (we share same release number cross all modules)
if (project.hasProperty("doRelease")) {
    apply from: 'gradle/release.gradle'
}

// Print out time taken for each task so we find things that are slow.
apply from: 'gradle/timing.gradle'

// The build script settings to fetch plugins and put them on
// classpath
buildscript {
    repositories {
        mavenCentral()
        jcenter()
    }

    dependencies {
        classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.1'
        classpath 'org.gradle.api.plugins:gradle-nexus-plugin:0.7.1'
        classpath 'com.github.townsfolk:gradle-release:1.2'
        classpath 'de.undercouch:gradle-download-task:1.1'
        classpath 'joda-time:joda-time:2.3'
        classpath 'com.adaptc.gradle:nexus-workflow:0.6'
	classpath "net.saliman:gradle-cobertura-plugin:2.2.7" // TEST for cobertura
    }
}

//
// Common configuration
//
ext {
    //
    // All published projects - their artifacts are going to Maven central
    publishedProjects = [
      project(':h2o-core'),
      project(':h2o-algos'),
      project(':h2o-web'),
      project(':h2o-app'),
      project(':h2o-scala'),
      project(':h2o-persist-hdfs'),
      project(':h2o-genmodel')
    ]

    javaProjects = [
      project(':h2o-core'),
      project(':h2o-algos'),
      project(':h2o-web'),
      project(':h2o-app'),
      project(':h2o-persist-hdfs'),
      project(':h2o-test-integ'),
      project(':h2o-genmodel')
    ]

    scalaProjects = [
      project(':h2o-scala')
    ]

    rProjects = [
      project(':h2o-r')
    ]

    pythonProjects = [
      project(':h2o-py')
    ]

    //
    // Versions of libraries shared cross all projects
    //
    junitVersion  = '4.11'
    jets3tVersion = '0.7.1'
    awsJavaSdkVersion = '1.8.3'

    //
    // H2O's REST API version
    //
    h2oRESTApiVersion = '3'
}

//
// For all projects (this and all subprojects) specify common properties and tasks
//
allprojects {
    group = 'ai.h2o'

    apply plugin: 'idea'
    apply plugin: 'eclipse'
    apply from: "$rootDir/gradle/artifacts.gradle"

    ext {
        isRelease = rootProject.hasProperty("doRelease")
    }
}

// Compute applyFindbugsPlugin property
// Gradle by default interpret boolean properties setup in config file as strings.
// Hence we need here string toBoolean call
def applyFindbugsPlugin = rootProject.hasProperty("runFindbugs") ? rootProject.runFindbugs.toBoolean() : false

// 
// Common configuration for all subprojects
//
subprojects {
    // All project inherits the same versioning number
    version = rootProject.version

    repositories {
        mavenCentral()
        maven {
          url "https://repository.cloudera.com/artifactory/cloudera-repos/"
        }
        maven {
          url "http://repo.hortonworks.com/content/repositories/releases/"
        }
        maven {
          url "http://repo.hortonworks.com/content/repositories/jetty-hadoop/"
        }
        maven {
          url "http://repository.mapr.com/maven/"
        }

        // mavenLocal()
    }
    // Publish artifacts - we should filter subproject in future but now apply publisher plugin
    // to all projects
    if (project in publishedProjects) {
      apply from: "$rootDir/gradle/publish.gradle"
    }

    apply from: "$rootDir/gradle/makeSupport.gradle"

    //
    // Early configuration of projects simplifies build resolution
    //

    // Configure Java projects
    if (project in javaProjects) {
        apply from: "$rootDir/gradle/java.gradle"
        apply from: "$rootDir/gradle/cp.gradle"
        // Include Findbugs only if the property is specified
        if (applyFindbugsPlugin) {
            apply from: "$rootDir/gradle/findbugs.gradle"
        }
    }

    // Configure Scala projects
    if (project in scalaProjects) {
        apply from: "$rootDir/gradle/scala.gradle"
        apply from: "$rootDir/gradle/cp.gradle"
    }

    if (project in rProjects) {
        apply from: "$rootDir/gradle/r.gradle"
    }

    if (project in pythonProjects) {
        apply from: "$rootDir/gradle/r.gradle"   // same plugins
    }
}

task wrapper(type: Wrapper) {
  gradleVersion = '2.3'
}

//
// Setup global properties shared by all projects
//
ext {
    // Collect all artifacts produced by all projects in this project - all "archives" artifacts
    allArchives = subprojects.findAll().inject(
            files(), { acc, pj -> 
          if (pj in publishedProjects)
            acc + pj.configurations.archives.allArtifacts.getFiles()
          else
            acc
    })
    // Collect all test artifacts
    allTestArchives = files() // filed lazily below

}

// After evaluation of all projects collect all artifacts produced by testArchives configuration
subprojects {
    afterEvaluate( { pj ->
        def testCnf = pj.configurations.findAll().find({ it.getName().equals("testArchives") })
        if (testCnf != null) allTestArchives = allTestArchives + testCnf.allArtifacts.getFiles()
    } )
}

// Include support for S3 syncing
apply from: "gradle/s3sync.gradle"

// This task is used by the Jenkins on test.h2o.ai.
//
// It creates a directory called 'target', copies everything to be released 
// there, and everything in that directory gets uploaded to S3.
//
// See ~jenkins/bin/buildh2odev.sh.
task buildH2oDevDist(type: Exec) {
    group='Dist'
    H2OBuildVersion bv = new H2OBuildVersion(rootDir, version);
    def projectVersion = bv.getProjectVersion()
    def branchName = bv.getBranch()
    def buildNumber = bv.getBuildNumber()
    def lastCommitHash = bv.getLastCommitHash()
    environment['PROJECT_VERSION'] = projectVersion
    environment['BRANCH_NAME'] = branchName
    environment['BUILD_NUMBER'] = buildNumber
    environment['LAST_COMMIT_HASH'] = lastCommitHash
    commandLine './make-dist.sh'
}

task dist(dependsOn: buildH2oDevDist) 

//
// Additional clean tasks to get squeaky clean.
//
task cleanH2oDistTmp(type: Delete) {
    delete "$rootDir/h2o-dist/tmp"
}

task cleanTarget(type: Delete) {
    delete "$rootDir/target"
}

clean.dependsOn cleanH2oDistTmp
clean.dependsOn cleanTarget

//
// Import project development profiles
//
apply from: "gradle/profiles.gradle"


//
// Tasks to generate code coverage report using Jacoco
// NOTE: As of now there isn't a way to merge tests reports from tests
//       that were run from h2o.jar with those run from other JAR files. 
//

apply plugin: 'jacoco'
ant.importBuild 'jacoco/instrument.xml'

repositories {
    mavenCentral()
}

task unpackJar(type: Sync) {
      FileTree jarRoot = zipTree("$rootDir/build/h2o.jar")
      def newDump = new File("$rootDir/build/jardump")
      if(newDump.exists()) {
  	newDump.deleteDir()
      }
      newDump.mkdirs()
      from jarRoot
      into newDump
      include "**/*.class"
}

//
// Generate a test report for all tests that are started from a shell script
// (Tests are ran from build.gradle in h2o-algos, h2o-core, and h2o-scala)
//
task jacocoShellReport (type: JacocoReport) {
    // String to help locate the directories of the source code
    String sourceDirEnd = "/src/main/java/"

    // Collect .exec files
    FileTree execLocation = fileTree(dir: "$rootDir", includes: ["h2o-algos/**/*.exec", "h2o-core/**/*.exec", "h2o-scala/**/*.exec"])
    executionData = execLocation

    // Collect source files
    FileTree sourceLocation = fileTree("$rootDir")
    sourceLocation.include ("**" + sourceDirEnd + "**")
    sourceLocation.each {File file ->
    	String fileDir = file.getParent() + "/"
	fileDir = fileDir.substring(0, (fileDir.lastIndexOf(sourceDirEnd) + sourceDirEnd.length()))
    	if (sourceDirectories == null) {
	   sourceDirectories = files(fileDir)
	} else {
           sourceDirectories = sourceDirectories + files(fileDir)
	}
    }

    // Collect class files
    FileTree classLocation = fileTree(dir: "$rootDir", include: "**/build/libs/**/*.jar", excludes: ["build/", "h2o-assembly/"])
    classDirectories = classLocation
    
    reports {
        xml.enabled true
	xml.destination "${buildDir}/reports/jacoco/algos-core-scala/xml"
        csv.enabled false
	html.enabled true
	html.destination "${buildDir}/reports/jacoco/algos-core-scala/html"
    }
}

//
// Generate a test report for all tests that are started from scripts/run.py
// (Tests are ran from build.gradle in h2o-test-integ, h2o-py, and h2o-r)
//
task jacocoRunReport (type: JacocoReport) {
    // String to help locate the directories of the source code
    String sourceDirEnd = "/src/main/java/"

    // Collect .exec files
    FileTree execLocation = fileTree(dir: "$rootDir", includes: ["py/testdir_multi_jvm/**/*.exec", "h2o-py/**/*.exec", "h2o-r/**/*.exec"])
    executionData = execLocation

    // Collect source files
    FileTree sourceLocation = fileTree("$rootDir")
    sourceLocation.include ("**" + sourceDirEnd + "**")
    sourceLocation.each {File file ->
    	String fileDir = file.getParent() + "/"
	fileDir = fileDir.substring(0, (fileDir.lastIndexOf(sourceDirEnd) + sourceDirEnd.length()))
    	if (sourceDirectories == null) {
	   sourceDirectories = files(fileDir)
	} else {
           sourceDirectories = sourceDirectories + files(fileDir)
	}
    }

    // Collect class files
    FileTree classLocation = fileTree("${buildDir}/jardump/")
    classDirectories = classLocation
    
    reports {
        xml.enabled true
	xml.destination "${buildDir}/reports/jacoco/test-integ/xml"
        csv.enabled false
	html.enabled true
	html.destination "${buildDir}/reports/jacoco/test-integ/html"
    }
}

task jacocoTestReport(overwrite: true)

task cleanCoverageData(type: Delete) {
    delete files("${buildDir}/jacoco_instrumented", "${buildDir}/jardump")
}

task cleanCoverageReports(type: Delete) {
    delete files("${buildDir}/reports/jacoco")
}

jacocoRunReport.dependsOn unpackJar
jacocoTestReport.dependsOn jacocoShellReport, jacocoRunReport

if (project.hasProperty("jacocoCoverage")) {
    test.dependsOn instrument
}